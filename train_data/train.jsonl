{"image": "hw2/05.png", "markdown": "## 4 Programming: Sortedness (15 points)\n\nFollow this https://classroom.github.com/a/K5V7mQ6CGitHub Classroom link to accept the assignment. Your code should be pushed to GitHub; do not include it here.\n\nAfter completing the sortedness test in sortedness.py, complete the following.\n\n* *From test_sortedness.py use generate_array(n, \\(\\epsilon\\)) to create almost-sorted arrays of size \\(n=1,000,000\\).\n* *Values for \\(\\epsilon\\) should vary starting at \\(10^{-1}\\) down to \\(10^{-5}\\) by multiplying with \\(10^{-1/2}\\) every time.\n* *On **each** of the generated arrays run your isEpsilonSorted function 100 times with the **same list** of \\(\\epsilon\\)-values as the one you used to generate the arrays and count how many times it returned sorted.\n* *For each array, plot the probability of isEpsilonSorted returning sorted and the \\(\\epsilon\\)-value you used. The \\(\\epsilon\\)-axis should be in logarithmic scale (use semilogx). What do you observe?\n* *Submit your plots in your GitHub Repository. Make sure that they are added to version control.", "meta": []}
{"image": "hw2/04.png", "markdown": "is ConstRandIsAllZero?\n\n### Boosting for one-sided error\n\nConsider the following algorithm.\n\n[H] Boosted Randomized\n\n``` function BoostRandIsAllZero(bit vector \\(\\alpha=(\\alpha_{1},\\alpha_{2},\\ldots,\\alpha_{n})\\), integer \\(k\\)) for\\(i=1\\)to\\(k\\)do if ConstRandIsAllZero(\\(a\\)) = \"No\" then return \"No\" endif endfor return \"Yes\" ```\n\n1. (f)(1 point) In the **all-zero** (correct output \"Yes\") case, what is the probability of a false negative? Briefly explain.\n2. (g)(1 point) In the **half-zero** (correct output \"No\") case, what is the probability of a false positive? Briefly explain.\n\n### Primality Testing\n\nThe public key cryptographic protocol RSA uses extremely long primes (at least 1024 bits long). As a result, we need to find very large primes efficiently. Fermat's little theorem states that \\(\\forall a\\in\\mathbb{N}^{+}\\ \\forall\\ \\text{primes }p:a^{p-1}\\equiv 1\\pmod{p}\\). In addition, for any composite number \\(q\\), at least half the integers \\(a\\) will be \"witnesses,\" meaning \\(a^{q-1}\\not\\equiv 1\\pmod{q}\\).\n\n[H] Fermat's Primality Test\n\n``` function IsPrime(\\(p\\)) Select \\(a\\in[p-1]\\) if\\(a^{p-1}\\equiv 1\\pmod{p}\\)then return \"Yes\" endif return \"No\" ```\n\n1. (h)(1 point) Between RP-type, coRP-type, and BPP-type, which one describes IsPrime? Why?\n2. (i)(1 point) If \\(p\\) is prime, what is the probability of a false negative? Briefly explain.\n3. (j)(1 point) If \\(p\\) is not prime, what is the probability of a false positive? Briefly explain.\n4. (k)(5 points) Follow this https://colab.research.google.com/drive/1mWG0AQpcnPepu_wEWcskbz3iUH7peY1F?usp=sharingGoogle Colab template link to implement Fermat primality testing and boosting. **Do not attempt to edit the linked file. Create your own copy instead by clicking File \\(\\rightarrow\\) Save a copy in Drive**. You do not need to write anything in your .pdf document for 3(k). When you have completed the notebook, download the .ipynb file. **Important: you must submit this problem separately from .pdf file which contains the rest of your theory solutions. Submit the completed .ipynb file to the Gradescope assignment named HW 2 - Problem 3(k) Notebook.**", "meta": []}
{"image": "hw2/03.png", "markdown": "### Different Types of Error\n\nIn computer science, problems with Yes/No answers are called decision problems. The above problem is an example of that class. Let's consider the possible outcomes that can occur in randomized algorithms for decision problems.\n\n\n\n* *A _false positive_ is when the correct output is No, but the algorithm outputs Yes. In statistical hypothesis testing this is also called a \"Type I error\".\n* *A _false negative_ is when the correct output is Yes, but the algorithm outputs No. In statistical hypothesis testing, this is also called a \"Type II error\".\n\nIn the current terminology of machine learning, the table itself is called a confusion matrix.\n\nConsider the following randomized algorithm for identifying an all-zero vector that only looks at a single bit.\n\n[H] Constant Time Randomized\n\n``` function ConstRandIsAllZero(bit vector \\(\\alpha=(\\alpha_{1},\\alpha_{2},\\ldots,\\alpha_{n})\\)) Pick \\(X\\in[n]\\) uniformly at random if\\(\\alpha_{X}=1\\)then return \"No\" endif return \"Yes\" ```\n\n1. (b)(1 point) Is Algorithm 1 a Las Vegas or Monte Carlo type algorithm? Why?\n2. (c)(1 point) If \\(\\alpha_{1}=\\alpha_{2}=\\ldots=0\\) (the **all-zero** case), what is the probability of a false negative? Briefly explain.\n3. (d)(1 point) If half of the \\(\\alpha\\)-vector is \\(0\\) (the **half-zero** case), what is the probability of a false positive? Briefly explain.\n\n### Types of Randomized Algorithms\n\nSo far you have characterized an algorithm as \"good\" or \"bad\" depending on the resources it needs, such as running time, memory, or network messages sent. However, in randomized algorithms we also care about false positive and false negative rate.\n\nThe first type of algorithms are the ones that for _every_ input whose correct output is No they always return No and for _every_ input whose correct output is Yes, the algorithm must output Yes with probability at least 1/2. These are called **randomized polynomial time** or **RP-type** algorithms.\n\nThe second type of algorithms are the ones that _every_ input whose correct output is Yes they always return Yes and for _every_ input whose correct output is No, the algorithm must output No with probability at least 1/2. These are called **coRP-type** algorithms.\n\n**RP-type** and **coRP-type** have **one-sided error**. When an algorithm has both, it is said to have **two-sided error**. For those algorithms a useful definition is **bounded-error probabilistic polynomial time** or **BPP-type** algorithms that have false positive and false negative error rate below 1/3.\n\n\n\n1. (e)(1 point) What kind of algorithm", "meta": []}
{"image": "hw1/01.png", "markdown": "# MPCS 55001 Algorithms Autumn 2023\n\nHomework 1\n\n Student Name  Student CnetID\n\nCollaborators: Student A, Student B\n\n**Instructions:** Write up your answers in LaTeX and submit them to Gradescope. **redHandwritten homework will not be graded.**\n\n**Collaboration policy:** You may work together with other students. If you do, state it at the beginning of your solution: **give the name(s) of collaborator(s)** and the nature and extent of the collaboration. Giving/receiving a hint counts as collaboration. Note: you must write up solutions **independently without assistance**.\n\n**Internet sources:** You must include the url of any internet source in your homework submission.\n\n## 1 Square Roots (8 points)\n\n1. [(a)]\n2. 1.(4 points) Given a positive integer \\(n\\), write **pseudocode** for a **recursive****divide-and-conquer** algorithm to find the floor of the square root of \\(n\\), \\(\\lfloor\\sqrt{n}\\rfloor\\).\n3. 2.(3 points) **Prove** the correctness of your algorithm using induction. (Recall that correctness proofs for recursive algorithms typically rely on induction, whereas correctness proofs for iterative algorithms typically rely on a loop invariant).\n4. 3.(1 point) Write and solve a running time recurrence for your algorithm.\n\n## 2 Closest Pair (12 points)\n\nIn this problem we will develop a divide-and-conquer algorithm for the following geometric task.\n\nClosest Pair\n\n_Input_: A set of points in the plane, \\(\\{p_{1}=(x_{1},y_{1}),p_{2}=(x_{2},y_{2}),\\ldots,p_{n}=(x_{n},y_{n})\\}\\).\n\n_Output_: The closest pair of points: that is, the pair \\(p_{i}\\neq p_{j}\\) for which the distance between \\(p_{i}\\) and \\(p_{j}\\), that is,\n\n\\[\\sqrt{(x_{i}-x_{j})^{2}+(y_{i}-y_{j})^{2}},\\]\n\nis minimized.\n\nFor simplicity, assume that \\(n\\) is a power of two, and that all the \\(x\\)-coordinates \\(x_{i}\\) are distinct, as are the \\(y\\)-coordinates.\n\nHere is a high-level overview of the algorithm:\n\n* *Find a value \\(x\\) for which exactly half the points have \\(x_{i}<x\\), and half have \\(x_{i}>x\\). On this basis, split the points into two groups, \\(L\\) and \\(R\\).\n* *Recursively find the closest pair in \\(L\\) and in \\(R\\). Say these pairs are \\(p_{L}\\), \\(q_{L}\\in L\\) and \\(p_{R},q_{R}\\in R\\), with distances \\(d_{L}\\) and \\(d_{R}\\), respectively. Let \\(d\\) be the smaller of these two distances.\n* *It remains to be seen whether there is a point in \\(L\\) and a point in \\(R\\) that are less than distance \\(d\\) apart from each other. To this end, discard all points with \\(x_{i}<x-d\\) or \\(x_{i}>x+d\\) and sort the remaining points by \\(y\\)-coordinate.", "meta": []}
{"image": "hw3/03.png", "markdown": "Give a **dynamic programming** algorithm that takes as input an array x[1..n] and a positive integer \\(k\\), and returns the lowest cost of any possible clustering with \\(k\\) or fewer clusters. The running time should be \\(O(n^{3}k)\\). Note: \\(O(n^{3}k)\\) is not necessarily the optimal running time!\n\n1. [(a)]\n2. 1.(4 points) Define the subproblem that you will use to solve this problem **precisely**. Define any variables you introduce. What are the dimensions of your dynamic programming table? What is the space complexity?\n3. 2.(4 points) Give a recurrence which expresses the solution to each subproblem in terms of smaller subproblems. State any base case(s). Justify your recurrence and state the time complexity of your recurrence.\n4. 3.(3 points) Write **pseudocode** for an algorithm to solve this problem. Argue that your algorithm runs in \\(O(n^{3}k)\\) time.\n5. 4.(2 points) Explain in a few sentences how you can improve the running time of your algorithm to \\(O(n^{2}k)\\). If your previous algorithm already runs in \\(O(n^{2}k)\\) time, you may leave this part blank for full credit.\n\n## 4 Programming: Document Reconstruction (20 points)\n\nFollow this https://classroom.github.com/a/GGfB4e5sGitHub Classroom link to accept the assignment. Your code should be pushed to GitHub; you do not need to include it here.", "meta": []}
{"image": "hw3/02.png", "markdown": "4. (e)(3 points) Modify your algorithm to run in time \\(O(n\\log n)\\). If you have already done so above, you do not need to answer this question.\n\n## 2 RNA Folding (12 points)\n\nA major difference between RNA and DNA is that RNA exists as a single strand that folds and pairs with itself. RNA consists of 4 different bases: adenine \\(\\mathtt{A}\\), cytosine \\(\\mathtt{C}\\), guanine \\(\\mathtt{G}\\), and uracil \\(\\mathtt{U}\\). Adenine pairs with uracil and cytosine pairs with guanine. There are many other factors, but generally RNA folds in a way that maximizes the number of pairs formed.\n\nIn this problem, we will consider the case where an RNA strand folds on itself in a single location. Consider the RNA strand \\(\\mathtt{AUUGCAGACGCU}\\). If the strand folds after the 6th base \\(\\mathtt{AUUGCA|GACGCU}\\), this is a possible result:\n\n\\[\\begin{array}[]{ccccccccc}\\mathtt{A}&\\mathtt{U}&\\mathtt{U}&\\mathtt{G}&\\mathtt{ C}&\\mathtt{A}&-&-&-\\\\ \\mathtt{U}&-&-&\\mathtt{C}&\\mathtt{G}&-&\\mathtt{C}&\\mathtt{A}&\\mathtt{G}\\end{array}\\]\n\nIf the strand folds after the 7th base \\(\\mathtt{AUUGCAG|ACGCU}\\), this is a possible result:\n\n\\[\\begin{array}[]{cccccccc}\\mathtt{A}&\\mathtt{U}&\\mathtt{U}&\\mathtt{G}&\\mathtt{C }&\\mathtt{A}&\\mathtt{G}&-\\\\ \\mathtt{U}&-&-&\\mathtt{C}&\\mathtt{G}&-&\\mathtt{C}&\\mathtt{A}\\end{array}\\]\n\nNote that after folding, the second half of the RNA strand is paired backwards and we are able to skip over bases when forming pairs. There are 3 pairs when folding after the 6th base and 4 pairs when folding after the 7th base; thus, we consider folding after the 7th base more optimal.\n\nDesign a **dynamic programming** algorithm which, when given a string \\(S[1\\dots n]\\) consisting of the characters \\(\\{\\mathtt{A},\\mathtt{C},\\mathtt{G},\\mathtt{U}\\}\\), returns the maximum number of pairs that can be formed by a single fold. Your algorithm should be as asymptotically efficient as possible.\n\n1. [(a)]\n2. 1.(4 points) Define the subproblem that you will use to solve this problem **precisely**. Define any variables you introduce.\n3. 2.(4 points) Give a recurrence which expresses the solution to each subproblem in terms of smaller subproblems. State any base case(s).\n4. 3.(3 points) Write **pseudocode** for an algorithm to solve this problem.\n5. 4.(1 point) Analyze the running time and space complexity of your algorithm.\n\n## 3 Clustering (13 points)\n\nThe problem of **clustering** a sorted sequence of one-dimensional points \\(x_{1},\\dots,x_{n}\\) entails splitting the points into \\(k\\) clusters (where \\(k\\leq n\\) is an input parameter) such that the sum of the squared distances from each point to its cluster mean is minimized.\n\nFor example, consider the following sequence with \\(n=5\\):\n\n\\[3,\\ 3,\\ 6,\\ 16,\\ 20\\]\n\nSuppose we want to partition it into \\(k=2\\) clusters. Here is one possible solution:\n\n\\[3,3\\mid 6,16,20\\]\n\nThe mean of the first cluster is \\((3+3)/2=3\\), and the mean of the second cluster is \\((6+16+20)/3=14\\). The cost (total variance) of this clustering is \\((3-3)^{2}+(3-3)^{2}+(6-14)^{2}+(16-14)^{2}+(20-14)^{2}=104\\). This clustering is not optimal because there exists a better one:\n\n\\[3,3,6\\mid 16,20\\]\n\nThe mean of the first cluster is \\((3+3+6)/3=4\\), and the mean of the second cluster is \\((16+20)/2=18\\). The cost of this clustering is \\((3-4)^{2}+(3-4)^{2}+(6-4)^{2}+(16-18)^{2}+(20-18)^{2}=14\\), which is optimal.", "meta": []}
{"image": "hw3/01.png", "markdown": "# MPCS 55001 Algorithms Autumn 2023\n\nHomework 3\n\n Student Name Student CnetID\n\nCollaborators: Student A, Student B\n\n**Instructions:** Write up your answers in LaTeX and submit them to Gradescope. **redHandwritten homework will not be graded.**\n\n**Collaboration policy:** You may work together with other students. If you do, state it at the beginning of your solution: **give the name(s) of collaborator(s)** and the nature and extent of the collaboration. Giving/receiving a hint counts as collaboration. Note: you must write up solutions **independently without assistance**.\n\n**Internet sources:** You must include the url of any internet source in your homework submission.\n\n## 1 Scheduling Problems (13 points)\n\n\n\nOn a computing system there are \\(N\\) jobs. Each job needs to run from moment \\(s_{i}\\) to moment \\(t_{i}\\). Unfortunately, the system cannot run jobs that overlap in the time they need to run. We want to run the greatest number of jobs possible.\n\n1. (a)(2 points) Prove that ordering the jobs in increasing finishing time \\(t_{i}\\) and greedily selecting the first job that has no conflicts achieves the optimum schedule.\n\nHowever, not all jobs are spawned equal. Each job is assigned a weight \\(w_{i}\\) and we want to select the subset \\(S\\) of non-overlapping jobs such that \\(\\sum_{i\\in S}w_{i}\\) is maximized. Unfortunately, this problem cannot be solved with a greedy algorithm. Give a **dynamic programming** algorithm that takes as input an array of jobs \\([(s_{1},t_{1},w_{1}),\\ldots,(s_{n},t_{n},w_{n})]\\) and returns the maximum possible sum of weights \\(w_{i}\\) of non-overlapping jobs that is achievable. The running time should be \\(O(n^{2})\\).\n\n1. (b)(2 points) Define the subproblem that you will use to solve this problem **precisely**. Define any variables you introduce. What are the dimensions of your dynamic programming table? What is the space complexity?\n2. (c)(3 points) Give a recurrence which expresses the solution to each subproblem in terms of smaller subproblems. State any base case(s). Justify your recurrence and state the time complexity of your recurrence.\n3. (d)(3 points) Write **pseudocode** for an algorithm to solve this problem. Argue that your algorithm runs in \\(O(n^{2})\\) time.", "meta": []}
{"image": "hw4/03.png", "markdown": "de the entire message? 3. (b)(1 point) Compute and draw the optimal Huffman code tree. 4. (c)(1 point) What is the number of bits needed to encode the entire message using the Huffman code? 5. (d)(2 points) Write pseudocode for an algorithm that takes a Huffman tree and outputs the letters in descending order of frequency. It should run \\(O(k)\\) time, where \\(k\\) is the size of the alphabet.", "meta": []}
{"image": "hw4/02.png", "markdown": "You will need to decide what extra information to store, modify the insert and delete operations to maintain the augmentation, and write pseudocode for the new operation. The insert and delete operations should still run in \\(O(\\log n)\\) time, where \\(n\\) is the number of elements in the tree. You may assume that the BST is balanced, and that the elements in the BST are distinct.\n\n1. [(a)]\n2. 1.(1 point) State which additional attribute(s) your augmented BST will maintain.\n3. 2.(2 points) Write (modified) **pseudocode** for Insert(T, x). Modify the algorithm from CLRS on page 294.\n4. 3.(3 points) Write (modified) **pseudocode** for Delete(T, x). Modify the algorithm from CLRS on page 298.\n5. 4.(3 points) Write **pseudocode** for SumBetween(T, x, y). It should run in \\(O(\\lg n)\\) time and output an integer.\n\n## 3 Dynamic Percentiles (12 points)\n\nYou are given access to a stream of numeric values of unknown length, e.g., \\(99,-22.4,\\dots\\). The values are not necessarily unique.\n\n1. [(a)]\n2. 1.(6 points) Design a data structure \\(D\\) which supports the following operations: * *D.ingest(x) stores the next value in the stream in the data structure. This should run in \\(O(\\log n)\\) time, where \\(n\\) is the number of values added thus far. * *D.median() returns the **true median** of the values added to the data structure thus far. This should run in \\(O(1)\\) time. The **true median** of a sorted sequence \\(a_{1},\\dots,a_{n}\\) is \\(a_{(n+1)/2}\\) if \\(n\\) is odd and \\((a_{n/2}+a_{(n/2)+1})/2\\) if \\(n\\) is even. Give a brief explanation of the data structure \\(D\\). Write **pseudocode** for both operations and justify their running time.\n3. 2.(3 points) Modify your data structure from part (a) to support computing an arbitrary percentile \\(p\\). For example, if \\(p=90\\), your data structure should be able to compute the first value greater than or equal to the 90th percentile of the values it has ingested. The value of \\(p\\) is provided as a parameter during initialization, i.e., D.init(p). The running time of the ingest(x) operation should be the same as in part (a), and the running time of the new D.percentile() operation should be the same as median() in part (a).\n4. 3.(3 points) Finally, design an enhanced data structure \\(S\\) which supports the median operation over a sliding window of size \\(k\\). The window size \\(k\\) is provided as a parameter during initialization. You may add an auxiliary data structure if you wish. Describe how you would modify ingest and median. For example, suppose \\(k=3\\) and the stream emits \\(10,85,44,15\\), which are ingested by the data structure. If the median operation is called after these four values are processed, it should return \\(44\\), as that is the median of the final 3 values. If the stream emits \\(12\\) and median is called again, it should return \\(15\\). For this data structure, the ingest operation should run in \\(O(\\log k)\\) time. The median operation should still run in \\(O(1)\\) time.\n\n## 4 Programming: Huffman Codes (20 points)\n\n1. [(a)]\n2. 1.(15 points) Follow this https://classroom.github.com/a/PAwHack1GitHub Classroom link to accept the assignment. Your code should be pushed to GitHub; you do not need to include it here.\n3. 2.In addition, there are a few short questions to answer here on LaTeX, after you finish your code. Consider an alphabet with letters a-h and the following counts in a message.  1. [(i)] 2. (a)(1 point) If every letter is encoded with a fixed length code of three bits, what is the number of bits needed to enco", "meta": []}
{"image": "hw4/01.png", "markdown": "# MPCS 55001 Algorithms Autumn 2023\n\nHomework 4\n\n Student Name Student CnetID\n\nCollaborators: Student A, Student B\n\n**Instructions:** Write up your answers in LaTeX and submit them to Gradescope. **redHandwritten homework will not be graded.**\n\n**Collaboration policy:** You may work together with other students. If you do, state it at the beginning of your solution: **give the name(s) of collaborator(s)** and the nature and extent of the collaboration. Giving/receiving a hint counts as collaboration. Note: you must write up solutions **independently without assistance**.\n\n**Internet sources:** You must include the url of any internet source in your homework submission.\n\n## 1 String Covering (8 points)\n\nGiven strings \\(S\\) and \\(T\\), we say that \\(S\\)_covers_\\(T\\) if \\(S\\) contains all of the same characters in \\(T\\), including duplicates.\n\nFor example, if \\(S=\\texttt{abcac}\\) and \\(T=\\texttt{ccba}\\), then \\(S\\) covers \\(T\\), but \\(T\\) does not cover \\(S\\). If \\(U=\\texttt{bcbc}\\), then \\(S\\) does not cover \\(U\\) and \\(U\\) does not cover \\(S\\).\n\n1. [(a)]\n2. 1.(4 points) Given two strings A[1..n] and B[1..m], compute the first index \\(k\\) such that A[1..k] covers \\(B\\), or NIL if such an index does not exist. Assume \\(B\\) can have duplicates, and that \\(n\\geq m\\) (otherwise there is obviously no solution). Write **pseudocode** for your algorithm, which should run in \\(O(n)\\)**expected** time.\n3. 2.(4 points) Given two strings A[1..n] and B[1..m], return the shortest contiguous substring A[i..j] such that A[i..j] covers \\(B\\). If there is no such substring, return NIL. Note that this can be solved in \\(O(n^{2})\\) expected time via repeated application of the algorithm in part (a) (taking \\(i=1\\), \\(i=2\\), and so on). Write **pseudocode** for an algorithm which runs in \\(O(n)\\) expected time.\n\n## 2 Augmented BSTs (9 points)\n\nMany problems call for a modified, or **augmented**, binary search tree. An augmented BST stores some extra information at each node in order to facilitate specific operations (in addition to the key, parent, and left/right children).\n\nFor example, at every node \\(v\\), you might store an attribute called \\(v.max\\) which stores the largest value in the subtree rooted at \\(v\\) (including \\(v\\) itself). This augmentation would allow you to answer queries like \"What is the maximum value in the BST?\" in \\(O(1)\\) time by simply looking at \\(T.root.max\\). Think about what modifications to the insert and delete operations would be necessary to maintain this augmentation.\n\nDesign an augmented BST to support a query of the form \\(\\code{SumBetween(T,x,y)}\\), which returns the sum of keys in \\(T\\) in the interval \\([x,y]\\) (including the endpoints, if they exist) in \\(O(\\lg n)\\) time. For example, the query SumBetween(T, 30, 51) on the below tree will return 91.\n\n[.**40** 28 [.62 **51** 75 ] ]\n\nThere are 2 keys in the tree between 30 and 51 (shown in boldface). Their sum is 91.", "meta": []}
